\chapter{基于特征融合的智能合约表征}
\section{本章内容}
\label{sec:本章内容3}
本章工作的目标是从智能合约源代码中提取专家特征和语义特征作为数据集，以便于训练深度学习模型用于进一步的研究工作。首先介绍了搜集以太坊智能合约源代码、并对数据进行过滤和预处理的方法，然后定义了专家特征和语义特征用于表征智能合约，接着描述了提取两种特征的方法，最终得到一个大规模的、包含专家特征和语义特征的以太坊智能合约数据集。
\section{数据搜集与预处理}
\label{sec:数据搜集与预处理}
\subsection{数据搜集}
\label{sec:数据搜集}
本文拟使用深度学习方法进行智能合约漏洞检测和运行时崩溃相关的研究，需要使用大量的智能合约源代码作为训练模型的数据集，而现有的相关工作中使用的数据集或多或少存在一些问题，如智能合约数量太少、Solidity版本过低、没有标注等，\autoref{tab:present_dataset_statistics}显示了现有的智能合约数据集的统计信息。
\begin{table}[htbp]
    \caption{\label{tab:present_dataset_statistics}现有工作中使用的数据集的统计信息}
    \small
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\linewidth}{cX<{\centering}X<{\centering}X<{\centering}p{3cm}}
        \hline
    数据集名称     & 智能合约数量 & 包含源代码 & 漏洞标签 & 合约最大创建时间            \\ \hline
    SmartBugs\cite{smartbugs} & 47518  & 是 & 无 & 2019年8月 \\
    ScrawID\cite{yashavant2022scrawld}    & 6780 & 是   & 有  & 2020年6月 \\
    Ren\cite{ren2021} &  45622 & 是 & 无 & 2020年12月 \\
    JiuZhou\cite{jiuzhou}   & 176  & 是  & 有   & 2019年9月 \\
    SmartCheck\cite{smartcheck}       & 4600   & 是 & 无 & 2018年11月  \\  \hline
    \end{tabularx}
\end{table}
另一方面，Solidity语言的更新会修复一些低版本智能合约中的漏洞，以太坊虚拟机的更新也会减少智能合约出现运行时异常的情况，因此搜集较新的智能合约源代码进行研究是十分必要的。\autoref{tab:solidity_evm_update}显示了自2018以年来Solidity语言和EVM的重要版本更新。

下一步是确定搜集何种数据以及如何搜集数据。本文的目标是研究智能合约的漏洞情况，以及在以太坊虚拟机上的执行情况，因此需要从以太坊网络获取至少产生过一笔交易的智能合约。相比于Github等代码托管平台上的智能合约源代码，从以太坊区块链上获取的智能合约更加具有现实意义。Evgeny\cite{bigquery_ethereum}在BigQuery\footnote{Google BigQuery 是 Google Cloud Platform 提供的一项企业级数据仓库服务，它允许执行快速的 SQL 查询和交互式分析大规模数据集}上创建并公开了以太坊数据库，包含以太坊区块链上智能合约和交易的所有信息。同时部署了自动化工具每天从以太坊中提取最新的数据，并将其同步到数据库中。另一方面，Etherscan\footnote{https://www.etherscan.io/}是一个以太坊区块链数据分析平台，提供了应用程序接口（Application Programming Interface，API）用于查询区块链上的数据。综上所述，搜集数据的方法包含2个步骤：首先使用BigQuery数据库收集至少有一笔交易的智能合约账户地址，然后将合约地址作为参数调用Etherscan相关的API得到智能合约的源代码等数据。
\begin{table}[htbp]
    \caption{\label{tab:solidity_evm_update}Solidity语言和EVM自2018年以来的版本更新}
    \small
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\linewidth}{p{1cm}p{7cm}<{\raggedright}X<{\raggedright}}
    \hline
    \textbf{年份} & \textbf{EVM更新内容} & \textbf{Solidity 更新内容} \\ \hline
    2018 & 性能优化，安全性增强 & 0.5.x: 明确可见性声明，引入新的数据位置 \\ \hline
    2019 & Gas成本优化，抗DDoS能力提升，以太坊与Zcash互操作性，智能合约创新功能 & 0.7.0: 禁止某些标识符，引入Unicode字符串，构造函数可见性废弃，严格状态可变性 \\ \hline
    2020 & 移除难度炸弹，应对区块生成时间增长问题 & 0.7.x: 新增error类型，废除fallback函数 \\ \hline
    2021 & 改变手续费结构，引入基础费与矿工费，销毁部分基础费以降低ETH流通量 & 0.8.x: 引入算术运算溢出检查，优化事件列表 \\ \hline
    2022 & PoW转PoS，验证节点与出块奖励变更，手续费与存储优化。 & 语言和编译器优化、支持新的以太坊功能 \\ \hline
    2023 & 质押提款功能，降低Layer-2解决方案Gas费，引入EOF优化智能合约字节码 & 0.9.0.alpha: 集成require()与Custom Error，IR优化，增强错误处理，引入EOF \\ \hline
    \end{tabularx}
    \end{table}
\subsection{数据预处理}
\label{sec:数据预处理}

最后一步需要对原始数据集进行预处理，过滤掉一些不符合期望的智能合约，我们设定了以下的排除规则：
\begin{itemize}
    \item \textbf{移除重复的合约}。有些合约可能会被重复部署，所以我们比较Solidity文件的MD5值，如果相同则排除其一。
    \item \textbf{移除交易数太少的合约}。交易数太少的合约可能含有严重的缺陷，没有足够的运行信息证明其安全性，所以研究意义不大。
    \item \textbf{移除编译错误的合约}。编译错误的合约无法运行，没有研究价值。
    \item \textbf{移除低版本的合约}。低于0.4.11的Solidity版本与更新版本存在较大差异，且可能在将来被废弃。
\end{itemize}

通过上述方法，我们首先在BigQuery中得到了\num{8183198}个智能合约地址，在Etherscan上获得的经过验证的合约源代码共有\num{133290}份，最后经过上述排除规则，我们总计得到了\num{54739}份智能合约源代码用于下文的研究。
\subsection{数据集标注}
\label{sec:数据集标注}
% \textcolor{red}{这里可能要给数据集打标签}
% 上文收集的数据集
根据不同类别的漏洞的出现概率及其在现实世界的重要性，本文选择4种漏洞作为研究对象：权限控制、算术错误、重入漏洞以及未检查调用。由于当前没有途径或方法获得智能合约的绝对标签，因此本文只能借鉴已有工作\cite{yashavant2022scrawld}，利用多种现有的漏洞检测工具对每一份智能合约进行处理，得到其标签后，根据每种漏洞能被检测出来的工具数量，设置不同的检出阈值，即该漏洞被多少种检测工具确认后才将其标注为真。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\linewidth]{pictures/dataset_labels}
    \caption{\label{fig:dataset_labels}本文搜集的智能合约数据集中各种漏洞的数量}
\end{figure}
比如共有3种工具能检测出智能合约中的重入漏洞，那么针对重入漏洞的检出阈值就为2，即当有两种检测工具都检测出某合约包含重入漏洞时，本文才将其标注为包含重入漏洞。通过上述方法，本文采用了5种广泛使用的漏洞检测工具，即Slither、Mythril、Oyente、Osiris和SmartCheck，并参照论文\cite{yashavant2022scrawld}设置4种漏洞的检出阈值，使用SmartBugs智能合约分析框架\cite{smartbugs}完成数据集标注工作，最终得到的数据集的统计信息如\autoref{fig:dataset_labels}所示。
% 由于当前没有高质量的已标注的智能合约源代码数据集，或者相关数据集中的源代码数量太少，因此本文需要自行标注搜集到的智能合约源代码。而当前


\section{基于静态度量定义专家特征}
\label{sec:基于静态度量定义专家特征}
在软件质量保证（Software Quality Assurance，SQA）工作中，静态代码指标（如 Halstead\cite{halstead}指标、McCabe\cite{mccabe}指标）发挥着重要作用。许多方法都是基于静态代码指标提出的，先前的工作\cite{menzies2007data,meyers2007empirical,zimmermann2007predicting}也证实了这些指标对软件质量保证研究是有用的。因此，我们认为智能合约也可以从中获益，借助静态代码指标对合约进行漏洞检测和运行时崩溃研究。

受先前工作\cite{halstead,mccabe,menzies2007data}的启发，本文定义了34个静态代码指标，其中22个与编程语言无关，这些指标进一步分为三个维度：复杂度度量指标、计数度量指标和面向对象度量指标；另外12个为Solidity语言相关的度量指标，这是因为智能合约与其他传统语言编写的程序有所不同，一些特性（如Gas机制）相关的指标可能会更精准地表征一个智能合约。

% 表\autoref{tab:metrics}显示了本文引入或定义的静态代码指标的概述，具体每个指标的含义将在下一小节阐述。

\subsection{静态代码度量的四个维度}
\label{sec:静态代码度量的四个维度}
\subsection{代码复杂度}
\label{sec:代码复杂度}

代码复杂度指标（Code Complexity Metrics）是用于量化软件源代码复杂性的度量标准。有研究表明\cite{Chen2019AnEI,singh2015bug}，代码复杂度指标与程序中的复杂缺陷存在一定的相关性，这些指标可用于评估代码的难以理解性、可维护性和潜在缺陷。直观地说，一段代码越复杂，它成为缺陷代码的概率就越高，因此可以利用代码复杂度指标建立缺陷预测模型。

本文结合已有工作，引入了关于Solidity文件的6个复杂度指标：平均圈复杂度、最大圈复杂度、圈复杂度总和、最大继承深度、最大嵌套度、合约耦合度。
\begin{enumerate}[label=(\arabic*)]
    \item 平均圈复杂度（AvgComplexity）\&最大圈复杂度（MaxComplexity）\&圈复杂度总和（SumComplexity）。
    圈复杂度用来衡量一个程序分支结构的复杂程度，在数量上表现为程序中可以独立执行的路径条数。我们从两个方面计算圈复杂度：1) 遍历并统计抽象语法树上相应函数节点下的所有分支语句（如 if、while、do while 和 for 等）；2）计算源代码文件中"\&\&"、"||"和"? : "的总数。因此，Solidity文件中的最大圈复杂度就是所有函数的圈复杂度的最大值，圈复杂度总和就是所有函数的圈复杂度之和，平均圈复杂度就是所有函数的圈复杂度之和与函数个数的比值。
    \item 最大继承深度（MaxInheritance）。
    Solidity作为面向对象的编程语言，合约之间可以存在继承关系，合约的最大继承深度表示当前合约在所有继承链\footnote{因为Solidity支持多重继承}中的路径长度。一个 Solidity 文件中可能有多个合约，但只有一个合约是主合约\footnote{类似于Java文件中的公开类}，其他合约都是辅助合约或继承合约，因此该指标计算的是主合约的最大继承深度。我们采用递归算法来计算这一指标，即当前合约的继承深度为父合约的继承深度值加1，如果某个合约没有父合约，则它的继承深度值为0。
    \item 最大嵌套度（MaxNesting）。
    最大嵌套度表示 Solidity 文件中函数内控制结构的最深嵌套级别。要计算单个函数的嵌套级别，我们需要遍历该函数中的所有语句，并计算从语句到函数定义的路径上分支语句的数量。因此，Solidity 文件的最大嵌套度为函数中的语句嵌套度中的最大值。
    \item 合约耦合度（CountContractCoupled）。
    合约耦合度指标衡量的是与当前合约存在耦合关系的合约数量，这个指标用来反映合约之间的关联情况。当一个合约的函数调用另一个合约的函数或访问其中的变量时，我们认为这两个合约是耦合的。我们将引用合约 C1 或被它引用的其他合约集合的大小作为合约 C1 的合约耦合度。
\end{enumerate}
\subsection{计数维度}
\label{sec:计数维度}
计数度量（Count Metrics）用于从物理层面（如代码行数、空行数或注释行数）来表示代码特征，Gyimothy 等人\cite{gyimothy2005}证实了计数相关的指标在缺陷预测工作中的实用性。直观地说，一个程序的代码量越大，出现缺陷代码的概率就越高。本文引入了6个计数相关的度量指标：代码行数（CountLineCode）、可执行代码行数（CountLineCodeExe）、注释行数（CountLineComment）、语句数（CountStmt）、空行数（CountLineBlank）、注释代码行数比（RatioCommentToCode），这些指标均见名知义，故不再详细介绍。
% \begin{enumerate}[label=(\arabic*)]
%     \item \textbf{代码行数（CountLineCode）}。即Solidity源代码文件的总行数。

%     \item \textbf{可执行代码行数（CountLineCodeExe）}。可执行代码行数指标计算的是 Solidity 源代码文件中的非空行和非注释行。也就是说，只计算包含实际Solidity语句的行数。为了计算这个指标，我们逐行扫描源代码，过滤掉所有空行和注释行，得到 CountLineCodeExe 指标。在 Solidity 编程语言中，有两种注释源代码的方法：单行注释（"//"）和多行注释（"/*...*/"）。因此，我们认为所有以"/*"、"*"、"//"开头或以 "*/"结尾的行都是注释行。
    
%     \item \textbf{注释行数（CountLineComment）}。该指标可以在上述可执行代码行数指标的计算过程中得到。
    
%     \item \textbf{语句数（CountStmt）}。即 Solidity 源代码文件中可执行语句的数量，可以从 Solidity 源代码对应的抽象语法树中计算语句定义的数量得到。
    
%     \item \textbf{空行数（CountLineBlank）}。即 Solidity 源代码文件中的空行数。
    
%     \item \textbf{注释代码行数比（RatioCommentToCode）}。即 Solidity 源代码文件中注释行数与代码行数的比值。
% \end{enumerate}
\subsection{面向对象维度}
\label{sec:面向对象维度}
面向对象的度量指标用于从高层次角度描述源代码的质量。面向对象设计思想的核心是用对象来模拟现实世界，这与强调面向函数的、将数据和程序分开的传统程序设计方式截然不同。先前的工作\cite{martin1994oodesign,basili1996validation,KHAN20071}证实了面向对象度量指标在缺陷预测工作中比传统指标（如代码复杂度指标、计数指标）更有效，下面介绍一些当前维度中比较重要的指标：
\begin{enumerate}[label=(\arabic*)]
    % \item 父合约个数（CountContractBase）。即Solidity文件中的主合约所继承的合约的数量。

    \item 依赖合约个数（CountDependence）。主合约除了直接依赖继承的父合约外，还间接依赖父合约所继承的合约，因此该指标计算两种合约的总数。

    % \item 合约个数（CountContract）。即Solidity源文件中定义的合约的数量。

    \item 内部函数个数（CountFunctionInternal）\& 外部函数个数（CountFunctionExternal） \& 私有函数个数（CountFunctionPrivate） \& 公开函数个数（CountFunctionPublic） \& 函数总数（CountTotalFunction）。
    在 Solidity 语言中，函数和状态变量有四种可见性类型，分别是：外部（external）、内部（internal）、公开（public）和私有（private），合约中定义的函数必须指定为这四种类型之一。然而对于状态变量，它们不能被标记为外部（external）类型。外部函数是合约接口的一部分，这意味着它们只能从合约外部被调用，包括其他合约或通过交易。公开函数也是合约接口的一部分，它们既可以在合约内部被调用，也可以从外部通过交易调用。对于标记为公开的状态变量，Solidity 会在合约中自动生成一个相应的获取器函数（getter）。内部函数和状态变量只能在当前合约或其派生合约内被访问。而私有的函数和状态变量则仅在其定义合约中可见，不能在派生合约中被访问。我们通过解析抽象语法树（AST）中的节点信息来分析这些不同类型的函数和状态变量。
    % \item 变量个数（CountVariable）& 公共变量个数（CountPublicVariable）。即Solidity源文件中的所有合约中的变量个数和被标记为公共变量的个数。
\end{enumerate}
\subsection{Solidity维度}
\label{sec:Solidity维度}
不同编程语言的特性对代码质量的影响各不相同， Solidity 作为一种专为智能合约设计的编程语言更是如此，其特性包括：全局状态、事件机制、Gas机制等。鉴于智能合约的这些特性，我们提出了针对Solidity语言的一系列启发式指标。

智能合约的设计目标是运行在以太坊网络节点的虚拟机上，因此其执行过程中对各种资源极为敏感，这也突出了Gas机制的重要性。在以太坊网络中，几乎所有智能合约操作均需消耗Gas，比如资金转移、数据存储、调用其他智能合约或记录运行日志等，不同操作消耗的Gas数量各不相同。因此，智能合约中的操作越多，消耗的Gas也就越多，进而增加合约因Gas耗尽而崩溃的风险\cite{qianpeng2022zh}。基于此，我们定义了八个度量指标：存储变量数、映射变量数、可支付函数数量、事件数量、函数修改器数量、转账语句数量、调用语句数量、代理调用语句数量。

此外，由于以太坊区块链的不可变性，部署在以太坊上的智能合约代码无法被更新，这一特性可能增加合约在执行过程中崩溃的风险。为此，我们定义了两个指标用于描述这种特性：静态函数数量和依赖库数量。

同时，我们认为良好的代码结构（例如模块化）对代码可读性和质量有重要影响。因此，我们引入了接口数量指标来评估代码结构的优劣。

总体而言，我们提出了12个Solidity特有的度量指标，下文将挑选一些重要的指标深入解析其含义和作用。

\begin{enumerate}[label=(\arabic*)]
    \item 存储变量数（NOSV）。以太坊虚拟机有三个可以存储数据的区域：storage、内存和堆栈。以太坊的每个账户都有一个名为 “storage”的数据区，它在函数调用和交易之间是持久的。不过，读取和写入的成本较高。存储变量数指标衡量的是 Solidity 源代码文件中定义了多少个存储在storage的变量。此外，有三种数据类型（即映射、数组和结构体）默认为storage类型的变量。定义的storage变量越多，执行该合约消耗的Gas也就越多，智能合约崩溃的概率就越高。
    \item 映射变量数（NOMap）。映射类型（Mapping）是 Solidity 编程语言中最常用的数据类型之一，支持存储键值对，类似于哈希表。但是，映射类型的key只能是基本数据类型，也没有内部变量记录元素的个数，而且也不支持像 “foreach循环”操作那样访问所有元素。因此，这种类型的变量会因为其诸多限制\footnote{由于原生的 Mapping 限制比较多，以太坊官方提供了一个扩展库 IterableMapping ，https://github.com/ethereum/dapp-bin/blob/master/library/iterable\_mapping.sol，增加了类似其他语言的映射类型的操作。}而增加智能合约漏洞和崩溃的风险。
    \item 可支付函数数量（NOPay）。可支付函数（Payable Function）提供了接收资金（以太币）转移的功能。然而，成功支付至少需要两个基本条件：发送方具有足够的Gas以及有效的接收方地址。因此，如果不满足这两个条件，合约运行中就会崩溃。可支付函数数量指标衡量 Solidity 源代码文件中定义了多少个可支付函数。
    % \item 事件数量（NOE）。Solidity 中的事件是对以太坊虚拟机日志功能的封装。应用程序可以通过以太坊客户端的 RPC 接口订阅并监听这些事件，以获取相应的消息。然而，事件也需要Gas来驱动。事件的使用量越多，Gas的消耗量就越大。
    % \item 函数修改器数量（NOMod）。修改器是函数的包装器，可以以声明的方式改变函数的行为。例如，我们可以使用修改器在执行特定函数之前做条件检查，当然这需要消耗Gas。
    % \item 转账语句数（NOT）。transfer是address类型数据的原生属性，用于向该地址对应的账户转账。调用transfer后会调用转账接收方的fallback函数，如果该函数逻辑太复杂会导致transfer执行失败，因此转账语句越多，合约运行崩溃的概率也就越高。
    \item 消息调用数（NOC）。消息调用（Message Call）用于智能合约之间的交互，进行消息调用需要提供源地址、目标地址、数据、以太币、Gas，发起一笔交易、调用其他合约的函数或者发送以太币到非合约账户都是消息调用，消息调用次数越多，合约出现运行异常的概率越高。
    % \item 委托调用数（NODC）。消息调用有一种变体——委托调用（Delegate Call），它与消息调用的不同之处在于，目标地址的代码将在发起调用的合约的上下文中执行。这意味着一个合约可以在运行时从另外一个地址动态加载代码，storage、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。委托调用可能会从被调用合约引入漏洞，因此该指标是有意义的。
    \item 静态函数数量（NOSF）。静态函数是指那些保证不会读取或修改状态变量的函数，在 Solidity 中用pure或view关键字修饰。
    \item 重写回调函数（SDFB）。当调用的函数签名与合约中任何函数都不匹配时，默认调用 fallback 函数。最好重新写fallback函数以应对未知的调用，同时使用 payable 修饰以接收转账，该指标表示是否重写了fallback函数。
    % \item 依赖库数量（NOL）。库（Library）是一种特殊的合约，其中的函数必须保证不修改状态。库被部署在特定地址后可以重复使用。然而库的质量直接影响了主合约的质量，如果库中存在分享代码，依赖它的智能合约就会包含潜在风险。该指标衡量了Solidity源文件中使用了多少库。
    % \item 接口数量（NOI）。良好的结构设计可以提高代码质量，接口（Interfact）将类的定义与实现分离开来，提供了更好的可读性和可扩展性。因此，使用接口进行模块化设计可以在一定程度上提高合约质量。
\end{enumerate}

\section{基于合约语义图提取语义特征}
\label{sec:基于合约语义图提取语义特征}
%描述一下语义信息对深度学习的意义。

已有许多工作证明，相比于源代码，基于图的表示法往往更能保留复杂程序的结构特征\cite{allamanis2017learning}，这有助于模型更好地理解程序的语义信息，从而提高在代码理解相关下游任务中的性能。这些与程序结构相关的图称为语义图（Semantic Graph），应用最广泛的语义图便是抽象语法树，此外还有数据流图、控制流图、函数调用图等，\autoref{sec:智能合约漏洞检测研究现状}中描述的污点分析法和符号执行法对控制流图和函数调用图有一定的应用。本文拟挖掘智能合约中的语义信息用于训练漏洞检测模型，因此在此章节引入智能合约的数据流图、控制流图和函数调用图，下面简单介绍一下这三种语义图。

\subsection{数据流图}
\label{sec:数据流图}
数据流图（Data Flow Graph，DFG）是一种表示变量之间依赖关系的有向图，其中节点表示变量，有向边表示变量值的流动方向。数据流图为模型理解程序的结构特征带来了关键的语义信息，已被广泛应用在各种程序分析工作中\cite{hellendoorn2019global,allamanis2018learning,guo2020graphcodebert}。

与AST不同的是，对于相同功能的程序，尽管各种语言的抽象语法不同，但数据流是相同的。以 $a=maxValue-minValue$ 为例，仅从变量a的名字是无法得知该变量值所代表的实际含义，但从数据流的角度来看，a的值来自maxValue和minValue的差，变量a的含义可能是一个数组的极差。

% 另一方面，数据流图的引入可以让模型更加关注变量之间的直接依赖关系。以图xxx为例，有四个名称相同但语义不同的变量（x1,x2,x3,x4），图中展示了这些变量之间的依赖关系，并表明x4与x3的关系相比于x2更加紧密，这样就极有可能让模型更加关注变量x3的值，从而发现潜在的漏洞。

另一方面，数据流图的引入可以让模型更加关注变量之间的直接依赖关系。假如有四个名称相同但语义不同的变量$x$，按照其位置信息得到的变量序列为$\left\{x_1, x_2, x_3, x_4\right\}$，这表明$x_4$与$x_3$的关系相比于与$x_2$更加紧密，这样就会让模型更加关注变量$x_3$的值，从而可能发现潜在的漏洞。
如果用形式化语言表述，将从AST中得到的变量序列记为$V=\left\{v_1, v_2, \ldots, v_k\right\}$，将表明了数据流动方向的边的集合表示为$E=\left\{\varepsilon_1, \varepsilon_2, \ldots, \varepsilon_l\right\}$，那么图$DFG(S)=(V, E)$表示源代码$S$中的数据流图。
%%%%%%%%%%%%%%%%%%%% 如果需要时再增加这部分内容 %%%%%%%%%%%%%%%
Wu等人\cite{wu2021peculiar}在研究智能合约的重入漏洞时，提出了关键数据流图（Curcial Graph Flow Data，CDFG）的概念。他们认为，智能合约的漏洞存在于几个关键语句中，整个数据流图中也只有部分信息对于漏洞检测任务有帮助。因此为了减少无用信息的干扰，他们通过剔除DFG中与漏洞无关的数据流关系，构建了关键数据流图，用来表达合约中与漏洞相关的关键语义信息。本文将沿用其思路与做法。
\subsection{控制流图}
\label{sec:控制流图}

控制流图（Control Flow Graph，CFG）是一个过程或程序逻辑的抽象表示，描述了程序在执行期间可能经过的所有路径。Allen于1970年提出控制流图的概念\cite{allencfg}，后来逐渐成为静态分析和编译器优化的重要工具。

在控制流图中，每个节点都表示一个基本代码块，即没有任何跳转指令的顺序执行的代码块，有向边表示程序的执行路径，在满足一定条件时，程序从一个基本代码块跳转到另一个基本代码块继续执行。控制流图可以帮助我们理解程序在运行时可能经过的所有路径，这对于理解程序的行为模式，以及寻找可能的逻辑错误或者漏洞等方面都有很大帮助。

如果用形式化语言表述，将从AST中得到的代码块序列记为$B=\left\{b_1, b_2,\ldots, b_m\right\}$，程序可能的执行路径记为$E=\left\{\gamma_1, \gamma_2, \ldots, \gamma_n\right\}$，那么图$CFG(S)=(B, E)$表示源代码$S$中的控制流图。

% 根据条件分支语句的判断条件

% 控制流图对应的是代码中的条件分支结构，在大多数高级编程语言中用if-else语句、while语句、for语句等表示。%%%%%%%%%%%%%%\textcolor{red}{图xx表示了图xx中的智能合约生成的控制流图}。


\subsection{函数调用图}
\label{sec:函数调用图}
函数调用图（Function Call Graph）是描述函数之间互相调用关系的有向图。他们在理解源代码，尤其是复杂的代码结构时非常有用。在函数调用图中，节点代表函数，边则代表调用关系，如果函数A调用函数B，那么函数调用图中会有一条从A到B的有向边。根据函数的调用顺序和相互关系，形成了一种树状或网状的结构。在智能合约中，函数可以使用不同的权限修饰符（如public、internal等）或语义修饰符（如pure、payable等），因此在创建智能合约的函数调用图时，可以针对被调用函数的修饰符对函数调用图的边进行分类，以表示该调用关系中被调用函数的类型。

如果用形式化语言表述，从AST的可执行语句\footnote{即非变量或函数的声明或定义语句，可以执行且影响相关变量的值的语句}中提取的函数名称组成一个序列$F=\left\{f_1, f_2, \ldots, f_n\right\}$，函数之间的调用关系记为$E=\left\{\xi_1, \xi_2, \ldots, \zeta_1, \zeta_2, \ldots, \delta_1, \delta_2, \ldots\right\}$，其中$\xi, \zeta, \delta$分别表示针对上文中提到的不同类型函数的调用，那么图$FCG(S)=(F, E)$表示源代码$S$中的函数调用图。%%%%%%%%%%%%%\textcolor{red}{图xx表示了智能合约生成的函数调用图}。


